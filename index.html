<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>KiteForecast — Finale correcties & verificatie</title>
<style>
:root{
  --bg:#eaf6ff; --card:#fff; --accent:#0b6fb8; --accent-dark:#075a92; --muted:#6b7b8a; --text:#042b3a;
  --calm:#dff6ff; --light:#bfefff; --moderate:#bff0d6; --fresh:#fff6c8; --strong:#ffd6b3; --very-strong:#ffb3b3; --extreme:#d7b3ff;
}
html,body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg),#f3fbff);color:var(--text)}
.wrap{max-width:980px;margin:18px auto;padding:12px}
header{display:flex;flex-direction:column;gap:6px}
h1{margin:0;font-size:1.4rem;color:var(--accent-dark)}
.subtitle{color:var(--muted);font-size:0.9rem}

/* Search area */
.searchRow{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
.searchCard{background:var(--card);padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(6,30,50,0.06);display:flex;gap:8px;align-items:center}
input[type="search"]{width:320px;padding:8px;border-radius:8px;border:1px solid #d7eefc;font-size:0.95rem}
.btn{background:var(--accent);color:#fff;padding:8px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
.quickButtons{display:flex;gap:6px}
.quickButtons button{background:#f0f8ff;border:1px solid #d7eefc;padding:8px 10px;border-radius:8px;color:var(--accent-dark);cursor:pointer;font-weight:700}

/* Spot card and table */
.spotCard{background:linear-gradient(180deg,#fff,#f7fbff);padding:12px;border-radius:10px;margin-top:12px;box-shadow:0 6px 18px rgba(6,30,50,0.04)}
.wf-table{width:100%;border-collapse:collapse;margin-top:12px;font-size:0.92rem}
.wf-table th{background:linear-gradient(180deg,#e6f6ff,#dff3ff);padding:8px;text-align:left}
.wf-table td{padding:8px;border-bottom:1px solid #f0f6fb}
.day-row{background:#f3fbff;font-weight:700;color:var(--accent)}
.slot-row:hover{background:#f7fdff}

/* Wind arrow (shaft + head) — langere shaft */
.wind-cell{display:flex;align-items:center;gap:8px}
.wind-arrow{width:34px;height:34px;position:relative;transform-origin:center center;display:inline-block}
.wind-arrow .shaft{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:2px;height:28px;background:#075a92;border-radius:2px}
.wind-arrow .head{position:absolute;left:50%;top:2px;transform:translateX(-50%);width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid #075a92}

/* pills and colors */
.speed-pill{display:inline-block;padding:6px 8px;border-radius:8px;font-weight:700;color:var(--text)}
.c-0{background:var(--calm)}.c-1{background:var(--light)}.c-2{background:var(--moderate)}.c-3{background:var(--fresh)}.c-4{background:var(--strong)}.c-5{background:var(--very-strong)}.c-6{background:var(--extreme)}
.pill{background:#e6f6ff;padding:6px 8px;border-radius:999px;font-weight:700}
.subtitle{color:var(--muted);font-size:0.9rem}

/* debug panel */
.debug{margin-top:12px;padding:10px;background:#fff;border-radius:8px;border:1px solid #eef;font-size:0.9rem;color:#234}
.debug pre{white-space:pre-wrap;font-size:0.85rem}

/* responsive */
@media(max-width:880px){ input[type="search"]{width:220px} }
@media(max-width:640px){ .wf-table th:nth-child(1), .wf-table td:nth-child(1){display:none} .wind-arrow{width:26px;height:26px} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h1>KiteForecast</h1>
        <div class="subtitle">Controle & correcties — Wijk aan Zee verificatie ingebouwd</div>
      </div>
    </div>
  </header>

  <div class="searchRow">
    <div class="searchCard" role="search">
      <input id="q" type="search" placeholder="Zoek spot — bijv. Tarifa, Langebaan, Scheveningen" />
      <button id="searchBtn" class="btn">Zoek</button>
      <div style="margin-left:8px" class="pill">kts</div>
    </div>

    <div class="quickButtons" aria-hidden="false">
      <button data-spot="wijk">Wijk aan Zee</button>
      <button data-spot="ouddorp">Ouddorp</button>
      <button data-spot="brouwersdam">Brouwersdam</button>
      <button data-spot="rockanje">Rockanje</button>
      <button data-spot="zandmotor">Zandmotor</button>
    </div>
  </div>

  <div id="results" class="subtitle" style="margin-top:8px"></div>
  <div id="spotCard"></div>

  <div id="debug" class="debug" style="display:none">
    <strong>Vergelijking met Windfinder (Wijk aan Zee 13:00)</strong>
    <pre id="debugText">Wacht op data...</pre>
  </div>
</div>

<script>
/*
  Belangrijkste correcties en verificatie:
  - Open-Meteo levert windsnelheden in m/s. We converteren exact één keer:
      1 m/s = 1.943844 kts
  - We tonen afgeronde gehele knopen (Math.round).
  - Winddirection uit API is 'from' (meteorologisch). Om de pijl te laten wijzen
    naar waar de wind heengaat, gebruiken we (deg + 180) % 360.
  - Superforecast (dagrange) wordt berekend als min–max van de afgeronde
    per-slot mean (windspeed_10m) en gusts over 08:00–20:00 (2-uurs slots).
  - Extra debug: na laden van Wijk aan Zee vergelijkt de app automatisch
    de 13:00 waarde met de door jou opgegeven Windfinder referentie:
      Windfinder (gegeven): 13:00 mean 10 - 16 kts ; super (dag) 10 - 14 kts
*/

const GEOCODE = name => `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(name)}&count=10&language=nl&format=json`;
const FORECAST = (lat,lon,days=10) => `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=windspeed_10m,windgusts_10m,winddirection_10m&current_weather=true&timezone=auto&forecast_days=${days}`;

/* conversion */
const KTS_PER_MS = 1.943844;
function msToKtsRounded(ms){
  if(!Number.isFinite(ms)) return null;
  return Math.round(ms * KTS_PER_MS);
}

/* color buckets */
function windColorClassFromKts(kts){
  if(!Number.isFinite(kts)) return 'c-0';
  const v = Number(kts);
  if(v < 5) return 'c-0';
  if(v < 10) return 'c-1';
  if(v < 15) return 'c-2';
  if(v < 20) return 'c-3';
  if(v < 25) return 'c-4';
  if(v < 35) return 'c-5';
  return 'c-6';
}

/* compass */
function degToCompass(deg){
  if(!Number.isFinite(deg)) return '—';
  const val = Math.floor((deg/22.5)+0.5);
  const arr = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
  return arr[val % 16];
}

/* quick spots */
const QUICK_SPOTS = {
  wijk: { name: "Wijk aan Zee", lat: 52.4410, lon: 4.6450 },
  ouddorp: { name: "Ouddorp", lat: 51.7830, lon: 3.9000 },
  brouwersdam: { name: "Brouwersdam", lat: 51.7000, lon: 3.9000 },
  rockanje: { name: "Rockanje", lat: 51.8500, lon: 4.1200 },
  zandmotor: { name: "Zandmotor", lat: 52.0200, lon: 4.1200 }
};

/* UI: search */
const resultsEl = document.getElementById('results');
document.getElementById('searchBtn').addEventListener('click', async ()=>{
  const q = document.getElementById('q').value.trim(); if(!q) return;
  resultsEl.textContent = 'Zoeken...';
  try{
    const r = await fetch(GEOCODE(q));
    const j = await r.json();
    if(!j.results || j.results.length===0){ resultsEl.textContent='Geen resultaten'; return; }
    resultsEl.innerHTML = j.results.map((s,i)=>`<div style="margin-top:6px"><button data-i="${i}" class="spotBtn" style="background:none;border:0;color:#075a92;cursor:pointer;font-weight:700">${s.name}${s.admin1? ', '+s.admin1:''}, ${s.country}</button></div>`).join('');
    document.querySelectorAll('.spotBtn').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        const idx = btn.dataset.i;
        const spot = j.results[idx];
        resultsEl.innerHTML = '';
        loadSpot({ name: spot.name, lat: spot.latitude, lon: spot.longitude, country: spot.country });
      });
    });
  }catch(e){
    resultsEl.textContent='Fout bij zoeken';
    console.error(e);
  }
});

/* quick buttons */
document.querySelectorAll('.quickButtons button').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const key = btn.dataset.spot;
    const spot = QUICK_SPOTS[key];
    resultsEl.innerHTML = '';
    document.getElementById('q').value = '';
    loadSpot({ name: spot.name, lat: spot.lat, lon: spot.lon });
  });
});

/* helper to find hourly index for local time slot */
function findHourlyIndexFor(dateStr, hour, hourlyTimes){
  const hh = String(hour).padStart(2,'0');
  const tStr = `${dateStr}T${hh}:00`;
  let idx = hourlyTimes.indexOf(tStr);
  if(idx !== -1) return idx;
  idx = hourlyTimes.findIndex(ts => ts.startsWith(`${dateStr}T${hh}:`));
  return idx;
}

/* main loader with Wijk-aan-Zee 13:00 verification */
async function loadSpot(spot){
  const container = document.getElementById('spotCard');
  container.innerHTML = `<div class="spotCard"><strong>${spot.name}</strong><div class="subtitle">Laden forecast…</div></div>`;
  try{
    const r = await fetch(FORECAST(spot.lat ?? spot.latitude, spot.lon ?? spot.longitude, 10));
    const j = await r.json();
    const cur = j.current_weather;
    const hourly = j.hourly;
    if(!hourly || !hourly.time){ container.innerHTML = `<div class="spotCard">Geen forecastdata beschikbaar</div>`; return; }

    // map time -> index
    const timeIndex = {}; hourly.time.forEach((t,i)=> timeIndex[t]=i);

    // days: next 10 days
    const days = []; for(let d=0; d<10; d++){ const dt=new Date(); dt.setDate(dt.getDate()+d); days.push(dt.toISOString().slice(0,10)); }

    // collect indices for 08,10,...,20 each day
    const slotsPerDay = {};
    days.forEach(dateStr=>{
      slotsPerDay[dateStr]=[];
      for(let h=8; h<=20; h+=2){
        const idx = findHourlyIndexFor(dateStr, h, hourly.time);
        if(idx !== -1 && idx !== undefined) slotsPerDay[dateStr].push(idx);
      }
    });

    // precompute super per day as day range (min-max) in kts for mean and gusts
    const superPerDay = {};
    for(const dateStr of days){
      const idxs = slotsPerDay[dateStr] || [];
      const meanKts = [];
      const gustKts = [];
      for(const idx of idxs){
        const s_ms = Number(hourly.windspeed_10m[idx]);
        const g_ms = Number(hourly.windgusts_10m?.[idx]);
        if(Number.isFinite(s_ms)) meanKts.push(msToKtsRounded(s_ms));
        if(Number.isFinite(g_ms)) gustKts.push(msToKtsRounded(g_ms));
      }
      const meanMin = meanKts.length ? Math.min(...meanKts) : null;
      const meanMax = meanKts.length ? Math.max(...meanKts) : null;
      const gustMin = gustKts.length ? Math.min(...gustKts) : null;
      const gustMax = gustKts.length ? Math.max(...gustKts) : null;
      superPerDay[dateStr] = { meanMin, meanMax, gustMin, gustMax };
    }

    // build html
    let html = `<div class="spotCard"><div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:800">${spot.name}${spot.country? ', '+spot.country:''}</div><div style="display:flex;gap:10px;align-items:center"><div class="pill">kts</div><div class="subtitle">Tijdzone: ${j.timezone || 'lokale tijd'}</div></div></div>`;

    // current weather (color sensitive)
    const curKtsRounded = Number.isFinite(cur?.windspeed) ? msToKtsRounded(cur.windspeed) : null;
    const curKtsDisplay = curKtsRounded !== null ? curKtsRounded : '—';
    const curClass = windColorClassFromKts(curKtsRounded);
    const curDir = degToCompass(cur?.winddirection);
    html += `<div style="margin-top:8px"><strong>Actueel:</strong> <span class="speed-pill ${curClass}">${curKtsDisplay} kts</span> • richting <strong>${curDir}</strong> • ${cur?.time?.replace('T',' ')||'—'}</div>`;

    // table header
    html += `<table class="wf-table"><thead><tr><th>Tijd</th><th>Wind</th><th>Stoot</th><th>Richting</th><th>Super (mean)</th><th>Super (gust)</th></tr></thead><tbody>`;

    // debug data collector for verification
    const debugRows = [];

    for(const dateStr of days){
      const idxs = slotsPerDay[dateStr];
      const sampleIdx = idxs?.[0] ?? hourly.time.findIndex(t=>t.startsWith(dateStr));
      const sampleTime = hourly.time[sampleIdx] || (dateStr + 'T08:00');
      const dayLabel = new Date(sampleTime).toLocaleDateString(undefined,{weekday:'short',day:'2-digit',month:'short'});
      html += `<tr class="day-row"><td colspan="6">${dayLabel}</td></tr>`;

      if(!idxs || idxs.length===0){
        html += `<tr><td colspan="6" class="subtitle">Geen data voor 08–20</td></tr>`;
        continue;
      }

      const superVals = superPerDay[dateStr];
      const superMeanText = (superVals.meanMin !== null && superVals.meanMax !== null) ? `${superVals.meanMin} - ${superVals.meanMax} kts` : '';
      const superGustText = (superVals.gustMin !== null && superVals.gustMax !== null) ? `${superVals.gustMin} - ${superVals.gustMax} kts` : '';
      const superMeanClass = (superVals.meanMin !== null) ? windColorClassFromKts((superVals.meanMin + superVals.meanMax)/2) : 'c-0';
      const superGustClass = (superVals.gustMin !== null) ? windColorClassFromKts((superVals.gustMin + superVals.gustMax)/2) : 'c-0';

      for(const idx of idxs){
        const t = hourly.time[idx].replace('T',' ');
        const s_ms = Number(hourly.windspeed_10m[idx]);
        const g_ms = Number(hourly.windgusts_10m?.[idx]);
        const dirDeg = Number(hourly.winddirection_10m?.[idx]);

        // convert once and round to integer knopen
        const s_kts_rounded = Number.isFinite(s_ms) ? msToKtsRounded(s_ms) : null;
        const s_kts_display = s_kts_rounded !== null ? s_kts_rounded : '—';
        const g_kts_rounded = Number.isFinite(g_ms) ? msToKtsRounded(g_ms) : null;
        const g_kts_display = g_kts_rounded !== null ? g_kts_rounded : '—';

        const dirLabel = Number.isFinite(dirDeg) ? degToCompass(dirDeg) : '—';
        // rotate arrow so the arrowhead points to where the wind is going:
        // API gives winddirection = direction FROM which wind blows -> add 180 to point TO
        const arrowRotation = Number.isFinite(dirDeg) ? ( (dirDeg + 180) % 360 ) : 0;
        const arrowStyle = `transform:rotate(${arrowRotation}deg)`;
        const speedClass = Number.isFinite(s_kts_rounded) ? windColorClassFromKts(s_kts_rounded) : 'c-0';

        html += `<tr class="slot-row">
          <td class="time">${t}</td>
          <td><span class="speed-pill ${speedClass}">${s_kts_display} kts</span><div class="subtitle" style="margin-top:4px">(${Number.isFinite(s_ms)? s_ms.toFixed(2)+' m/s':''})</div></td>
          <td><span class="subtitle">${g_kts_display} kts</span><div class="subtitle" style="margin-top:4px">(${Number.isFinite(g_ms)? g_ms.toFixed(2)+' m/s':''})</div></td>
          <td><div class="wind-cell"><span class="wind-arrow" style="${arrowStyle}"><span class="shaft"></span><span class="head"></span></span><span class="subtitle">${dirLabel}</span></div></td>
          <td>${superMeanText ? `<span class="speed-pill ${superMeanClass}">${superMeanText}</span>` : ''}</td>
          <td>${superGustText ? `<span class="speed-pill ${superGustClass}">${superGustText}</span>` : ''}</td>
        </tr>`;

        // collect debug row
        debugRows.push({
          time: t,
          wind_m_s: Number.isFinite(s_ms) ? Number(s_ms.toFixed(3)) : null,
          wind_kts_rounded: s_kts_rounded,
          gust_m_s: Number.isFinite(g_ms) ? Number(g_ms.toFixed(3)) : null,
          gust_kts_rounded: g_kts_rounded,
          wind_deg_from: Number.isFinite(dirDeg) ? dirDeg : null,
          wind_compass_from: Number.isFinite(dirDeg) ? degToCompass(dirDeg) : null,
          arrow_rotation_to: arrowRotation
        });
      }
    }

    html += `</tbody></table></div>`;
    container.innerHTML = html;

    // hide results list and clear search input after loading
    resultsEl.innerHTML = '';
    document.getElementById('q').value = '';

    // If spot is Wijk aan Zee, run the verification against the Windfinder reference you provided
    if(spot.name.toLowerCase().includes('wijk')){
      verifyWijk(debugRows, j.timezone);
    } else {
      // hide debug if not Wijk
      document.getElementById('debug').style.display = 'none';
    }

  }catch(e){
    console.error(e);
    container.innerHTML = `<div class="spotCard">Fout bij laden forecast</div>`;
  }
}

/* Verification routine for Wijk aan Zee 13:00 using the Windfinder reference:
   Windfinder (user): 13:00 mean 10 - 16 kts ; super (day) 10 - 14 kts
   This routine finds the 13:00 slot in the debugRows, compares raw m/s and converted kts,
   and prints a short diagnostic explaining any discrepancy.
*/
function verifyWijk(debugRows, timezone){
  const debugPanel = document.getElementById('debug');
  const debugText = document.getElementById('debugText');
  debugPanel.style.display = 'block';

  // find the first row with time ending in '13:00' (local time string format)
  const row1300 = debugRows.find(r => r.time.endsWith('13:00') || r.time.includes(' 13:00'));
  // reference values from user
  const refMeanMin = 10, refMeanMax = 16; // Windfinder mean range for 13:00 (user)
  const refSuperMin = 10, refSuperMax = 14; // Windfinder superforecast day range (user)

  let out = { note: '', found1300: !!row1300, timezone };

  if(!row1300){
    out.note = 'Geen 13:00 slot gevonden in de API data voor deze dag (controleer timezone of beschikbaarheid van hourly slots).';
    debugText.textContent = JSON.stringify(out, null, 2);
    return;
  }

  // Compare values
  out.api = row1300;
  out.reference = {
    mean_13_00: `${refMeanMin} - ${refMeanMax} kts`,
    super_day: `${refSuperMin} - ${refSuperMax} kts`
  };

  // Determine whether our conversion matches the reference
  const apiMean = row1300.wind_kts_rounded;
  const apiGust = row1300.gust_kts_rounded;

  out.comparison = {
    mean_13_00_api: apiMean !== null ? `${apiMean} kts` : 'n.v.t.',
    gust_13_00_api: apiGust !== null ? `${apiGust} kts` : 'n.v.t.',
    matches_mean_range: (apiMean >= refMeanMin && apiMean <= refMeanMax),
    explanation: ''
  };

  // To diagnose superforecast mismatch we need the day's superPerDay computed earlier.
  // We can't access that object here directly, but we can approximate by scanning debugRows for today's rows.
  const today = row1300.time.split(' ')[0]; // YYYY-MM-DD or localized; fallback: use first part
  // Collect all debug rows for the same date prefix
  const datePrefix = row1300.time.split(' ')[0];
  const rowsSameDate = debugRows.filter(r => r.time.startsWith(datePrefix) || r.time.includes(datePrefix) || r.time.includes('13:00'));
  // If rowsSameDate is empty, fallback to all debugRows
  const candidateRows = rowsSameDate.length ? rowsSameDate : debugRows;

  // compute min/max mean and gust from candidateRows (only slots we displayed)
  const meanVals = candidateRows.map(r => r.wind_kts_rounded).filter(v => Number.isFinite(v));
  const gustVals = candidateRows.map(r => r.gust_kts_rounded).filter(v => Number.isFinite(v));
  const meanMin = meanVals.length ? Math.min(...meanVals) : null;
  const meanMax = meanVals.length ? Math.max(...meanVals) : null;
  const gustMin = gustVals.length ? Math.min(...gustVals) : null;
  const gustMax = gustVals.length ? Math.max(...gustVals) : null;

  out.super_estimate = {
    meanMin, meanMax, gustMin, gustMax
  };

  // Compare to reference super day
  out.comparison.matches_super = (meanMin !== null && meanMax !== null) ? (meanMin <= refSuperMax && meanMax >= refSuperMin) : false;

  // Build explanation
  if(out.comparison.matches_mean_range && out.comparison.matches_super){
    out.comparison.explanation = 'De API raw waarden (m/s) zijn correct geconverteerd naar knopen en vallen binnen de Windfinder referentiewaarden. Geen verdere correctie nodig.';
  } else {
    // Diagnose likely causes
    const reasons = [];
    // 1) If API mean differs significantly from reference, show raw m/s and converted kts
    if(!out.comparison.matches_mean_range){
      reasons.push('De geconverteerde 13:00 waarde wijkt af van Windfinder. Mogelijke oorzaken:');
      reasons.push('- Windfinder gebruikt mogelijk een ander model of smoothing (andere resolutie of tijdsaggregratie).');
      reasons.push('- Windfinder kan 10-minuten gemiddelde of een ander modelniveau tonen; Open‑Meteo hourly is model output per uur/slot.');
      reasons.push('- Controleer of Windfinder de mean of gust toont in de kolom die je vergelijkt.');
      reasons.push(`API raw: ${row1300.wind_m_s} m/s → ${row1300.wind_kts_rounded} kts (afgerond).`);
      reasons.push(`Windfinder (gegeven): ${refMeanMin} - ${refMeanMax} kts.`);
    }
    if(!out.comparison.matches_super){
      reasons.push('De superforecast (dagrange) wijkt af. Mogelijke oorzaken:');
      reasons.push('- Verschil in welke slots Windfinder gebruikt voor de dagrange (sommigen gebruiken 06–18 of 09–21).');
      reasons.push('- Windfinder kan extra filtering/smoothing toepassen op dagrange.');
      reasons.push(`API geschatte dagrange (mean): ${meanMin} - ${meanMax} kts.`);
      reasons.push(`Windfinder (gegeven dagrange): ${refSuperMin} - ${refSuperMax} kts.`);
    }
    out.comparison.explanation = reasons.join('\n');
  }

  debugText.textContent = JSON.stringify(out, null, 2);
}

/* Auto-load Wijk aan Zee on first open for quick verification */
window.addEventListener('load', ()=> {
  // auto-click quick button for Wijk aan Zee to speed verification
  const btn = document.querySelector('.quickButtons button[data-spot="wijk"]');
  if(btn) btn.click();
});
</script>
</body>
</html>
